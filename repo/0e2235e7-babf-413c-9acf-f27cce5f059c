var fromMarcGenre = {
//		"abstract or summary":XXX,
//		"abstract":XXX,
//		"summary":XXX,
	"art reproduction": "artwork",
	article: "journalArticle",
	autobiography: "book",
	bibliography: "book",
	biography: "book",
	book: "book",
	//		"calendar":XXX,
	//		"catalog":XXX,
	chart: "artwork",
	"comic or graphic novel": "book",
	comic: "book",
	"graphic novel": "book",
	"comic strip": "artwork",
	"conference publication": "conferencePaper",
	//		"database":XXX,
	dictionary: "dictionaryEntry",
	diorama: "artwork",
	//		"directory":XXX,
	drama: "book",
	encyclopedia: "encyclopediaArticle",
	//		"essay":XXX,
	festschrift: "book",
	fiction: "book",
	//		"filmography":XXX,
	filmstrip: "videoRecording",
	//		"findingaid":XXX,
	//		"flash card":XXX,
	folktale: "book",
	//		"font":XXX,
	//		"game":XXX,
	graphic: "artwork",
	globe: "map",
	handbook: "book",
	history: "book",
	hymnal: "book",
	"humor,satire": "book",
	humor: "book",
	satire: "book",
	//		"index":XXX,
	//		"instruction":XXX,
	//		"interview":XXX,
	//		"issue":XXX,
	journal: "journalArticle",
	kit: "artwork",
	//		"language instruction":XXX,
	"law report or digest": "journalArticle",
	"law report": "journalArticle",
	digest: "journalArticle",
	"law digest": "journalArticle",
	"legal article": "journalArticle",
	"legal case and case notes": "case",
	"legal case": "case",
	"case notes": "case",
	legislation: "statute",
	"loose-leaf": "manuscript",
	map: "map",
	memoir: "book",
	"microscope slide": "artwork",
	model: "artwork",
	//		"multivolume monograph":XXX,
	novel: "book",
	//		"numeric data":XXX,
	//		"offprint":XXX,
	"online system or service": "webpage",
	"online system": "webpage",
	service: "webpage",
	"online service": "webpage",
	patent: "patent",
	periodical: "journalArticle",
	picture: "artwork",
	//		"poetry":XXX,
	//		"programmed text":XXX,
	realia: "artwork",
	//		"rehearsal":XXX,
	//		"remote sensing image":XXX,
	//		"reporting":XXX,
	//		"review":XXX,
	script: "book",
	//		"series":XXX,
	//		"short story":XXX,
	slide: "artwork",
	sound: "audioRecording",
	speech: "audioRecording",
	"standard or specification": "report",
	standard: "report",
	//		"specification":XXX,
	//		"statistics":XXX,
	//		"survey of literature":XXX,
	"technical report": "report",
	newspaper: "newspaperArticle",
	theses: "thesis",
	thesis: "thesis",
	//		"toy":XXX,
	transparency: "artwork",
	//		"treaty":XXX,
	videorecording: "videoRecording",
	letter: "letter",
	"motion picture": "film",
	"art original": "artwork",
	"web site": "webpage",
	yearbook: "book"
};

var toMarcGenre = {
	artwork: "art original",
	audioRecording: "sound",
	bill: "legislation",
	blogPost: "web site",
	book: "book",
	bookSection: "book",
	case: "legal case and case notes",
	// "computerProgram":XXX,
	conferencePaper: "conference publication",
	dictionaryEntry: "dictionary",
	// "document":XXX,
	email: "letter",
	encyclopediaArticle: "encyclopedia",
	film: "motion picture",
	forumPost: "web site",
	hearing: "government publication",
	instantMessage: "letter",
	interview: "interview",
	journalArticle: "journal",
	letter: "letter",
	magazineArticle: "periodical",
	// "manuscript":XXX,
	map: "map",
	newspaperArticle: "newspaper",
	patent: "patent",
	podcast: "speech",
	// "presentation":XXX,
	radioBroadcast: "sound",
	report: "technical report",
	statute: "legislation",
	thesis: "thesis",
	// "tvBroadcast":XXX,
	videoRecording: "videorecording",
	webpage: "web site"
};

var dctGenres = {
	// "collection":XXX,
	// "dataset":XXX,
	// "event":XXX,
	image: "artwork",
	interactiveresource: "webpage",
	// "model":XXX,
	movingimage: "videoRecording",
	// "physical object":XXX,
	// "place":XXX,
	// "resource":XXX,
	// "service":XXX,
	software: "computerProgram",
	sound: "audioRecording",
	stillimage: "artwork"
	// "text":XXX
};

var fromTypeOfResource = {
	// "text":XXX,
	cartographic: "map",
	// "notated music":XXX,
	"sound recording-musical": "audioRecording",
	"sound recording-nonmusical": "audioRecording",
	"sound recording": "audioRecording",
	"still image": "artwork",
	"moving image": "videoRecording",
	// "three dimensional object":XXX,
	"software, multimedia": "computerProgram"
};

var toTypeOfResource = {
	artwork: "still image",
	audioRecording: "sound recording",
	bill: "text",
	blogPost: "software, multimedia",
	book: "text",
	bookSection: "text",
	case: "text",
	computerProgram: "software, multimedia",
	conferencePaper: "text",
	dictionaryEntry: "text",
	document: "text",
	email: "text",
	encyclopediaArticle: "text",
	film: "moving image",
	forumPost: "text",
	hearing: "text",
	instantMessage: "text",
	interview: "text",
	journalArticle: "text",
	letter: "text",
	magazineArticle: "text",
	manuscript: "text",
	map: "cartographic",
	newspaperArticle: "text",
	patent: "text",
	podcast: "sound recording-nonmusical",
	presentation: "mixed material",
	radioBroadcast: "sound recording-nonmusical",
	report: "text",
	statute: "text",
	thesis: "text",
	tvBroadcast: "moving image",
	videoRecording: "moving image",
	webpage: "software, multimedia"
};

var modsTypeRegex = {
//	'artwork':
//	'audioRecording': /\bmusic/i,
//	'bill':
	blogPost: /\bblog/i,
	//	'book':
	//	'bookSection':
	//	'case':
	//	'computerProgram':
	//	'conferencePaper':
	//	'dictionaryEntry':
	//	'email':
	//	'encyclopediaArticle':
	//	'film':
	//	'forumPost':
	//	'hearing':
	//	'instantMessage':
	//	'interview':
	journalArticle: /journal\s*article/i,
	//	'letter':
	magazineArticle: /magazine\s*article/i,
	//	'manuscript':
	//	'map':
	newspaperArticle: /newspaper\*article/i
//	'patent':
//	'podcast':
//	'presentation':
//	'radioBroadcast':
//	'report':
//	'statute':
//	'thesis':
//	'tvBroadcast':
//	'videoRecording':
//	'webpage':
};

var modsInternetMediaTypes = {
	// a ton of types listed at http://www.iana.org/assignments/media-types/index.html
	'text/html': 'webpage'
};

var marcRelators = {
	aut: "author",
	edt: "editor",
	ctb: "contributor",
	pbd: "seriesEditor",
	trl: "translator",
	cmp: "composer",
	lyr: "wordsBy",
	prf: "performer",
	cre: "author",
	rcp: "recipient"
};

// Item types that are part of a larger work
var partialItemTypes = ["blogPost",
	"bookSection",
	"conferencePaper",
	"dictionaryEntry",
	"encyclopediaArticle",
	"forumPost",
	"journalArticle",
	"magazineArticle",
	"newspaperArticle",
	"webpage"];

// Namespace array for using ZU.xpath
var ns = "http://www.loc.gov/mods/v3",
	xns = { m: ns };

function detectImport() {
	let doc;
	try {
		doc = Zotero.getXML().documentElement;
	}
	catch (err) {
		// most likely just not XML
		return false;
	}

	if (!doc) {
		return false;
	}
	return doc.namespaceURI === "http://www.loc.gov/mods/v3" && (doc.tagName.endsWith("modsCollection") || doc.tagName.endsWith("mods"));
}

/**
 * If property is defined, this function adds an appropriate XML element as a child of
 * parentElement.
 * @param {Element} parentElement The parent of the new element to be created.
 * @param {String} elementName The name of the new element to be created.
 * @param {Any} property The property to inspect. If this property is defined and not
 *     null, false, or empty, a new element is created whose textContent is its value.
 * @param {Object} [attributes] If defined, this object defines attributes to be added
 *     to the new element.
 */
function mapProperty(parentElement, elementName, property, attributes) {
	if (!property && property !== 0) return null;
	var doc = parentElement.ownerDocument,
		newElement = doc.createElementNS(ns, elementName);
	if (attributes) {
		for (let i in attributes) {
			newElement.setAttribute(i, attributes[i]);
		}
	}
	newElement.appendChild(doc.createTextNode(property));
	parentElement.appendChild(newElement);
	return newElement;
}

function doExport() {
	Zotero.setCharacterSet("utf-8");
	var parser = new DOMParser();
	var doc = parser.parseFromString('<modsCollection xmlns="http://www.loc.gov/mods/v3" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.loc.gov/mods/v3 http://www.loc.gov/standards/mods/v3/mods-3-2.xsd" />', 'application/xml');
	
	var item;
	let titleInfo;
	while (item = Zotero.nextItem()) { // eslint-disable-line no-cond-assign
		// Don't export notes or standalone attachments
		if (item.itemType === "note" || item.itemType === "attachment") continue;
		
		var mods = doc.createElementNS(ns, "mods"),
			isPartialItem = partialItemTypes.includes(item.itemType),
			recordInfo = doc.createElementNS(ns, "recordInfo"),
			host = doc.createElementNS(ns, "relatedItem"),
			series = doc.createElementNS(ns, "relatedItem"),
			topOrHost = (isPartialItem ? host : mods);
		
		/** CORE FIELDS **/
		
		// XML tag titleInfo; object field title
		if (item.title) {
			titleInfo = doc.createElementNS(ns, "titleInfo");
			mapProperty(titleInfo, "title", item.title);
			mods.appendChild(titleInfo);
		}
		
		if (item.shortTitle) {
			titleInfo = doc.createElementNS(ns, "titleInfo");
			titleInfo.setAttribute("type", "abbreviated");
			mapProperty(titleInfo, "title", item.shortTitle);
			mods.appendChild(titleInfo);
		}
		
		// XML tag typeOfResource/genre; object field type
		mapProperty(mods, "typeOfResource", toTypeOfResource[item.itemType]);
		mapProperty(mods, "genre", item.itemType, { authority: "local" });
		mapProperty(topOrHost, "genre", toMarcGenre[item.itemType], { authority: "marcgt" });
		
		// XML tag genre; object field thesisType, type
		if (item.thesisType) {
			mapProperty(mods, "genre", item.thesisType);
		}
		else if (item.type) {
			mapProperty(mods, "genre", item.type);
		}
		
		// XML tag name; object field creators
		for (let j = 0; j < item.creators.length; j++) {
			var creator = item.creators[j],
				roleTerm = "";
			if (creator.creatorType == "author") {
				roleTerm = item.itemType == "letter" ? "cre" : "aut";
			}
			else if (creator.creatorType == "editor") {
				roleTerm = "edt";
			}
			else if (creator.creatorType == "translator") {
				roleTerm = "trl";
			}
			else if (creator.creatorType == "seriesEditor") {
				roleTerm = "pbd";
			}
			else if (creator.creatorType == "composer") {
				roleTerm = "cmp";
			}
			else if (creator.creatorType == "wordsBy") {
				roleTerm = "lyr";
			}
			else if (creator.creatorType == "performer") {
				roleTerm = "prf";
			}
			else if (creator.creatorType == "recipient") {
				roleTerm = "rcp";
			}

			else {
				roleTerm = "ctb";
			}

			const name = doc.createElementNS(ns, "name");
			
			if (creator.fieldMode == 1) {
				name.setAttribute("type", "corporate");
				
				mapProperty(name, "namePart", creator.lastName);
			}
			else {
				name.setAttribute("type", "personal");
				
				mapProperty(name, "namePart", creator.lastName, { type: "family" });
				mapProperty(name, "namePart", creator.firstName, { type: "given" });
			}
			
			var role = doc.createElementNS(ns, "role");
			mapProperty(role, "roleTerm", roleTerm,
				{ type: "code", authority: "marcrelator" });
			name.appendChild(role);
			
			var creatorParent = (creator.creatorType === "seriesEditor")
				? series
				: ((creator.creatorType === "editor") ? topOrHost : mods);
			creatorParent.appendChild(name);
		}
		
		// XML tag recordInfo.recordOrigin; used to store our generator note
		// mods.recordInfo.recordOrigin = "Zotero for Firefox "+Zotero.Utilities.getVersion();
		
		/** FIELDS ON NEARLY EVERYTHING BUT NOT A PART OF THE CORE **/
		
		// XML tag recordInfo.recordContentSource; object field source
		mapProperty(recordInfo, "recordContentSource", item.libraryCatalog);
		
		// XML tag accessCondition; object field rights
		mapProperty(mods, "accessCondition", item.rights);
		
		/** SUPPLEMENTAL FIELDS **/
		
		var part = doc.createElementNS(ns, "part");
		
		// XML tag detail; object field volume
		const details = ["volume", "issue", "section"];
		for (let i = 0; i < details.length; i++) {
			if (item[details[i]] || item[details[i]] === 0) {
				const detail = doc.createElementNS(ns, "detail"),
					number = doc.createElementNS(ns, "number");
				detail.setAttribute("type", details[i]);
				number.appendChild(doc.createTextNode(item[details[i]]));
				detail.appendChild(number);
				part.appendChild(detail);
			}
		}
		
		// XML tag detail; object field pages
		if (item.pages) {
			var extent = doc.createElementNS(ns, "extent");
			extent.setAttribute("unit", "pages");
			if (item.pages.search(/^\d+[-–]\d+$/) != -1) {
				var range = ZU.getPageRange(item.pages);
				mapProperty(extent, "start", range[0]);
				mapProperty(extent, "end", range[1]);
			}
			else {
				extent.setAttribute("unit", "pages");
				mapProperty(extent, "list", item.pages);
			}
			part.appendChild(extent);
		}
		
		// Assign part if something was assigned
		if (part.hasChildNodes()) {
			// For a journal article, bookSection, etc., the part is the host
			topOrHost.appendChild(part);
		}
		
		var originInfo = doc.createElementNS(ns, "originInfo");
		
		// XML tag originInfo; object fields edition, place, publisher, year, date
		mapProperty(originInfo, "edition", item.edition);
		if (item.place) {
			var place = doc.createElementNS(ns, "place"),
				placeTerm = doc.createElementNS(ns, "placeTerm");
			placeTerm.setAttribute("type", "text");
			placeTerm.appendChild(doc.createTextNode(item.place));
			place.appendChild(placeTerm);
			originInfo.appendChild(place);
		}
		if (item.publisher) {
			mapProperty(originInfo, "publisher", item.publisher);
		}
		else if (item.distributor) {
			mapProperty(originInfo, "distributor", item.publisher);
		}
		if (item.date) {
			let dateType;
			if (["book", "bookSection"].includes(item.itemType)) {
				// Assume year is copyright date
				dateType = "copyrightDate";
			}
			else if (["journalArticle", "magazineArticle", "newspaperArticle"].includes(item.itemType)) {
				// Assume date is date issued
				dateType = "dateIssued";
			}
			else {
				// Assume date is date created
				dateType = "dateCreated";
			}
			mapProperty(originInfo, dateType, item.date);
		}

		if (item.numPages) {
			var physicalDescription = doc.createElementNS(ns, "physicalDescription");
			mapProperty(physicalDescription, "extent", item.numPages + " p.");
			mods.appendChild(physicalDescription);
		}

		if (isPartialItem) {
			// eXist Solutions points out that these types are more often
			// continuing than not & will use this internally.
			// Perhaps comment this out in the main distribution, though.
			if (["journalArticle", "magazineArticle", "newspaperArticle"].includes(item.itemType)) {
				mapProperty(originInfo, "issuance", "continuing");
			}
			else if (["bookSection",
				"conferencePaper",
				"dictionaryEntry",
				"encyclopediaArticle"].includes(item.itemType)) {
				mapProperty(originInfo, "issuance", "monographic");
			}
		}
		else {
			// eXist Solutions points out that most types are more often
			// monographic than not & will use this internally.
			// Perhaps comment this out in the main distribution, though.
			mapProperty(originInfo, "issuance", "monographic");
		}

		if (originInfo.hasChildNodes()) {
			// For a journal article, bookSection, etc., the part is the host
			topOrHost.appendChild(originInfo);
		}
		
		// XML tag identifier; object fields ISBN, ISSN
		mapProperty(topOrHost, "identifier", item.ISBN, { type: "isbn" });
		mapProperty(topOrHost, "identifier", item.ISSN, { type: "issn" });
		mapProperty(mods, "identifier", item.DOI, { type: "doi" });
		
		// XML tag relatedItem.name; object field conferenceName
		if (item.conferenceName) {
			const name = doc.createElementNS(ns, "name");
			name.setAttribute("type", "conference");
			mapProperty(name, "namePart", item.conferenceName);
		}
		
		// XML tag relatedItem.titleInfo; object field publication
		if (item.publicationTitle) {
			titleInfo = doc.createElementNS(ns, "titleInfo");
			mapProperty(titleInfo, "title", item.publicationTitle);
			host.appendChild(titleInfo);
		}
		
		// XML tag relatedItem.titleInfo; object field journalAbbreviation
		if (item.journalAbbreviation) {
			titleInfo = doc.createElementNS(ns, "titleInfo");
			titleInfo.setAttribute("type", "abbreviated");
			mapProperty(titleInfo, "title", item.journalAbbreviation);
			host.appendChild(titleInfo);
		}
		
		// XML tag classification; object field callNumber
		mapProperty(topOrHost, "classification", item.callNumber);

		// XML tag location.url; object field url
		if (item.url) {
			const location = doc.createElementNS(ns, "location");
			var url = mapProperty(location, "url", item.url, { usage: "primary display" });
			if (url && item.accessDate) url.setAttribute("dateLastAccessed", item.accessDate);
			mods.appendChild(location);
		}
				
		// XML tag location.physicalLocation; object field archiveLocation
		if (item.archiveLocation) {
			const location = doc.createElementNS(ns, "location");
			mapProperty(location, "physicalLocation", item.archiveLocation);
			topOrHost.appendChild(location);
		}
		
		// XML tag abstract; object field abstractNote
		mapProperty(mods, "abstract", item.abstractNote);
		
		// XML tag series/titleInfo; object field series, seriesTitle, seriesText, seriesNumber
		titleInfo = doc.createElementNS(ns, "titleInfo");
		mapProperty(titleInfo, "title", item.series);
		mapProperty(titleInfo, "title", item.seriesTitle);
		mapProperty(titleInfo, "subTitle", item.seriesText);
		if (titleInfo.hasChildNodes()) series.appendChild(titleInfo);
		
		if (item.seriesNumber) {
			const seriesPart = doc.createElementNS(ns, "part"),
				detail = doc.createElementNS(ns, "detail"),
				number = doc.createElementNS(ns, "number");
			detail.setAttribute("type", "volume");
			number.appendChild(doc.createTextNode(item.seriesNumber));
			detail.appendChild(number);
			seriesPart.appendChild(detail);
			series.appendChild(seriesPart);
		}
		
		/** NOTES **/
		
		if (Zotero.getOption("exportNotes")) {
			for (let j = 0; j < item.notes.length; j++) {
				mapProperty(mods, "note", item.notes[j].note);
			}
		}
		
		/** TAGS **/
		
		for (let j = 0; j < item.tags.length; j++) {
			var subject = doc.createElementNS(ns, "subject"),
				topic = doc.createElementNS(ns, "topic");
			topic.appendChild(doc.createTextNode(item.tags[j].tag));
			subject.appendChild(topic);
			mods.appendChild(subject);
		}

		/** LANGUAGE **/
		
		if (item.language) {
			var language = doc.createElementNS(ns, "language");
			mapProperty(language, "languageTerm", item.language, { type: "text" });
			mods.appendChild(language);
		}

		/** EXTRA->NOTE **/
		mapProperty(mods, "note", item.extra);
		
		if (recordInfo.hasChildNodes()) mods.appendChild(recordInfo);
		if (host.hasChildNodes()) {
			host.setAttribute("type", "host");
			mods.appendChild(host);
		}
		if (series.hasChildNodes()) {
			series.setAttribute("type", "series");
			topOrHost.appendChild(series);
		}
		doc.documentElement.appendChild(mods);
	}
	
	Zotero.write('<?xml version="1.0"?>\n');
	var serializer = new XMLSerializer();
	Zotero.write(serializer.serializeToString(doc));
}

function processTitleInfo(titleInfo) {
	var title = ZU.xpathText(titleInfo, "m:title[1]", xns).trim();
	var subtitle = ZU.xpathText(titleInfo, "m:subTitle[1]", xns);
	if (subtitle) title = title.replace(/:$/, '') + ": " + subtitle.trim();
	var nonSort = ZU.xpathText(titleInfo, "m:nonSort[1]", xns);
	if (nonSort) title = nonSort.trim() + " " + title;
	var partNumber = ZU.xpathText(titleInfo, "m:partNumber[1]", xns);
	var partName = ZU.xpathText(titleInfo, "m:partName[1]", xns);
	if (partNumber && partName) title = title.replace(/\.$/, '') + ". " + partNumber.trim() + ": " + partName.trim();
	else if (partNumber) title = title.replace(/\.$/, '') + ". " + partNumber.trim();
	else if (partName) title = title.replace(/\.$/, '') + ". " + partName.trim();
	return title;
}

function processTitle(contextElement) {
	// Try to find a titleInfo element with no type specified and a title element as a
	// child
	var titleElements = ZU.xpath(contextElement, "m:titleInfo[not(@type)][m:title][1]", xns);
	if (titleElements.length) return processTitleInfo(titleElements[0]);
	
	// That failed, so look for any titleInfo element without no type secified
	var title = ZU.xpathText(contextElement, "m:titleInfo[not(@type)][1]", xns);
	if (title) return title;
	
	// That failed, so just go for the first title
	return ZU.xpathText(contextElement, "m:titleInfo[1]", xns);
}

function processGenre(contextElement) {
	// Try to get itemType by treating local genre as Zotero item type
	var genre = ZU.xpath(contextElement, 'm:genre[@authority="local"]', xns);
	for (let i = 0; i < genre.length; i++) {
		const genreStr = genre[i].textContent;
		if (Zotero.Utilities.itemTypeExists(genreStr)) return genreStr;
	}
	
	// Try to get MARC genre and convert to an item type
	genre = ZU.xpath(contextElement, 'm:genre[@authority="marcgt"] | m:genre[@authority="marc"]', xns);
	for (let i = 0; i < genre.length; i++) {
		const genreStr = genre[i].textContent;
		if (fromMarcGenre[genreStr]) return fromMarcGenre[genreStr];
	}
	
	// Try to get DCT genre and convert to an item type
	genre = ZU.xpath(contextElement, 'm:genre[@authority="dct"]', xns);
	for (let i = 0; i < genre.length; i++) {
		const genreStr = genre[i].textContent.replace(/\s+/g, "");
		if (dctGenres[genreStr]) return dctGenres[genreStr];
	}
	
	// Try unlabeled genres
	genre = ZU.xpath(contextElement, 'm:genre', xns);
	for (let i = 0; i < genre.length; i++) {
		const genreStr = genre[i].textContent;
		
		// Zotero
		if (Zotero.Utilities.itemTypeExists(genreStr)) return genreStr;
		
		// MARC
		if (fromMarcGenre[genreStr]) return fromMarcGenre[genreStr];
		
		// DCT
		var dctGenreStr = genreStr.replace(/\s+/g, "");
		if (dctGenres[dctGenreStr]) return dctGenres[dctGenreStr];
		
		// Try regexps
		for (let type in modsTypeRegex) {
			if (modsTypeRegex[type].exec(genreStr)) return type;
		}
	}
	
	return undefined;
}

function processItemType(contextElement) {
	var type = processGenre(contextElement);
	if (type) return type;
	
	// Try to get type information from typeOfResource
	var typeOfResource = ZU.xpath(contextElement, 'm:typeOfResource', xns);
	for (let i = 0; i < typeOfResource.length; i++) {
		var typeOfResourceStr = typeOfResource[i].textContent.trim();
		
		// Try list
		if (fromTypeOfResource[typeOfResourceStr]) {
			return fromTypeOfResource[typeOfResourceStr];
		}
		
		// Try regexps
		for (let type in modsTypeRegex) {
			if (modsTypeRegex[type].exec(typeOfResourceStr)) return type;
		}
	}
	
	// Try to get genre data from host
	var hosts = ZU.xpath(contextElement, 'm:relatedItem[@type="host"]', xns);
	for (let i = 0; i < hosts.length; i++) {
		type = processGenre(hosts[i]);
		if (type) return type;
	}
		
	// Figure out if it's a periodical
	var periodical = ZU.xpath(contextElement,
		'm:relatedItem[@type="host"]/m:originInfo/m:issuance[text()="continuing" or text()="serial"]',
		xns).length;

	// Try physicalDescription/internetMediaType
	var internetMediaTypes = ZU.xpath(contextElement, 'm:physicalDescription/m:internetMediaType', xns);
	for (let i = 0; i < internetMediaTypes.length; i++) {
		var internetMediaTypeStr = internetMediaTypes[i].textContent.trim();
		if (modsInternetMediaTypes[internetMediaTypeStr]) {
			return modsInternetMediaTypes[internetMediaTypeStr];
		}
	}
	
	var isLetter = !!ZU.xpath(contextElement,
		'm:name/m:role/m:roleTerm[@type="code"][contains(@authority, "marc") or contains(@authority, "MARC")][text()="rcp"]',
		xns).length;
	if (isLetter) {
		return 'letter';
	}
	
	// for US congressional publications
	// (this is a nonstandard extension field)
	var isHearing = !!ZU.xpath(contextElement, '//m:congCommittee', xns).length;
	if (isHearing) {
		return 'hearing';
	}

	// As a last resort, if it has a host, let's set it to book chapter, so we can import
	// more info. Otherwise default to document
	if (hosts.length) {
		if (periodical) return 'journalArticle';
		return 'bookSection';
	}
	
	return "document";
}

function processCreator(name, itemType, defaultCreatorType) {
	var creator = {};
	creator.firstName = ZU.xpathText(name, 'm:namePart[@type="given"]', xns, " ") || undefined;
	creator.lastName = ZU.xpathText(name, 'm:namePart[@type="family"]', xns, " ");
	
	if (!creator.lastName) {
		var isPersonalName = name.getAttribute("type") === "personal",
			backupName = ZU.xpathText(name, 'm:namePart[not(@type="date")][not(@type="termsOfAddress")]', xns, (isPersonalName ? " " : ": "));
		
		if (!backupName) return null;
		
		if (isPersonalName) {
			let cleanedBackupName = backupName.replace(/[[(][^A-Za-z]*[\])]/g, '');
			creator = ZU.cleanAuthor(cleanedBackupName,
				"author", cleanedBackupName.includes(','));
			delete creator.creatorType;
		}
		else {
			creator.lastName = ZU.trimInternal(backupName);
			creator.fieldMode = 1;
		}
	}
	
	if (!creator.lastName) return null;

	// Look for roles
	let roles = ZU.xpath(name, 'm:role/m:roleTerm[@type="text" or not(@type)]', xns);
	var validCreatorsForItemType = ZU.getCreatorsForType(itemType);
	for (let role of roles) {
		const roleStr = role.textContent.toLowerCase();
		if (validCreatorsForItemType.includes(roleStr)) {
			creator.creatorType = roleStr;
		}
	}
	
	// we want to exclude names with no role other than publisher, distributor,
	// etc., because they aren't really creators in Zotero's sense of the term
	// (and they'll end up in other fields later). so we'll keep track of whether
	// we've encountered one of [pbl, dst] and *no other* relator types, and if
	// we do, we throw the creator away.
	let onlyPublisher;
	
	if (!creator.creatorType) {
		// Look for MARC roles
		roles = ZU.xpath(name, 'm:role/m:roleTerm[@type="code"][contains(@authority, "marc") or contains(@authority, "MARC")]', xns);
		for (let i = 0; i < roles.length; i++) {
			const roleStr = roles[i].textContent.toLowerCase();
			if (roleStr == 'pbl' || roleStr == 'dst') {
				if (onlyPublisher === undefined) {
					onlyPublisher = true;
				}
			}
			else {
				onlyPublisher = false;
			}
			let marcType = marcRelators[roleStr];
			if (marcType && validCreatorsForItemType.includes(marcType)) {
				creator.creatorType = marcRelators[roleStr];
			}
		}
		
		if (!creator.creatorType) creator.creatorType = defaultCreatorType;
	}
	
	if (onlyPublisher) {
		return null;
	}

	return creator;
}

function processCreators(contextElement, newItem, defaultCreatorType) {
	var names = ZU.xpath(contextElement, 'm:name', xns);
	for (let i = 0; i < names.length; i++) {
		var creator = processCreator(names[i], newItem.itemType, defaultCreatorType);
		if (creator) newItem.creators.push(creator);
	}
}

function processExtent(extent, newItem) {
	// try to parse extent according to
	// http://www.loc.gov/standards/mods/v3/mods-userguide-elements.html#extent
	// i.e. http://www.loc.gov/marc/bibliographic/bd300.html
	// and http://www.loc.gov/marc/bibliographic/bd306.html
	var extentRe = new RegExp(
		'^(.*?)(?=(?:[:;]|$))'	// extent [1]
		+ '(?::.*?(?=(?:;|$)))?'	// other physical details
		+ '(?:;(.*))?'				// dimensions [2]
		+ '$'							// make sure to capture the rest of the line
	);

	var ma = extentRe.exec(extent);
	if (ma && ma[1]) {
		// drop supplemental info (i.e. everything after +)
		if (ma[1].includes('+')) {
			ma[1] = ma[1].slice(0, ma[1].indexOf('+'));
		}

		// pages
		if (!newItem.pages && ZU.fieldIsValidForType('pages', newItem.itemType)) {
			const pages = ma[1].match(/\bp(?:ages?)?\.?\s+([a-z]?\d+(?:\s*-\s*[a-z]?\d+))/i);
			if (pages) {
				newItem.pages = pages[1].replace(/\s+/, '');
			}
		}

		// volume
		if (!newItem.volume && ZU.fieldIsValidForType('volume', newItem.itemType)) {
			var volume = ma[1].match(/\bv(?:ol(?:ume)?)?\.?\s+(\d+)/i);
			if (volume) {
				newItem.volume = volume[1];
			}
		}

		// issue
		if (!newItem.issue && ZU.fieldIsValidForType('issue', newItem.itemType)) {
			var issue = ma[1].match(/\b(?:no?|iss(?:ue)?)\.?\s+(\d+)/i);
			if (issue) {
				newItem.issue = issue[1];
			}
		}

		// numPages
		if (!newItem.numPages && ZU.fieldIsValidForType('numPages', newItem.itemType)) {
			const pages = ma[1].match(/(\d+)\s*p(?:ages?)?\b/i);
			if (pages) {
				newItem.numPages = pages[1];
			}
		}

		// numberOfVolumes
		if (!newItem.numberOfVolumes && ZU.fieldIsValidForType('numberOfVolumes', newItem.itemType)) {
			// includes volumes, scores, sound (discs, but I think there could be others)
			// video (cassette, but could have others)
			var nVol = ma[1].match(/(\d+)\s+(?:v(?:olumes?)?|scores?|sound|video)\b/i);
			if (nVol) {
				newItem.numberOfVolumes = nVol[1];
			}
		}

		// runningTime
		if (!newItem.runningTime && ZU.fieldIsValidForType('runningTime', newItem.itemType)) {
			// several possible formats:
			var rt;
			// 002016 = 20 min., 16 sec.
			if (rt = ma[1].match(/\b(\d{2,3})(\d{2})(\d{2})\b/)) { // eslint-disable-line no-cond-assign
				newItem.runningTime = rt[1] + ':' + rt[2] + ':' + rt[3];
			// (ca. 124 min.)
			}
			// eslint-disable-next-line no-cond-assign
			else if (rt = ma[1].match(/((\d+)\s*((?:hours?|hrs?)|(?:minutes?|mins?)|(?:seconds?|secs?))\.?\s+)?((\d+)\s*((?:hours?|hrs?)|(?:minutes?|mins?)|(?:seconds?|secs?))\.?\s+)?((\d+)\s*((?:hours?|hrs?)|(?:minutes?|mins?)|(?:seconds?|secs?))\.?)/i)) {
				var hrs = 0, mins = 0, secs = 0;
				for (let i = 2; i < 7; i += 2) {
					if (!rt[i]) continue;

					switch (rt[i].charAt(0).toLowerCase()) {
						case 'h':
							hrs = rt[i - 1];
							break;
						case 'm':
							mins = rt[i - 1];
							break;
						case 's':
							secs = rt[i - 1];
							break;
					}
				}

				if (secs > 59) {
					mins += secs / 60;
					secs %= 60;
				}
				if (secs < 10) {
					secs = '0' + secs;
				}

				if (mins > 59) {
					hrs += hrs / 60;
					mins %= 60;
				}
				if (mins < 10) {
					mins = '0' + mins;
				}

				newItem.runningTime = ((hrs * 1) ? hrs + ':' : '') + mins + ':' + secs;
			// (46:00)
			}
			else if (rt = ma[1].match(/\b(\d{0,3}:\d{1,2}:\d{2})\b/)) { // eslint-disable-line no-cond-assign
				newItem.runningTime = rt[1];
			}
		}
	}

	// dimensions: artworkSize
	// only part of artwork right now, but maybe will be in other types in the future
	if (!newItem.artworkSize && ma && ma[2] && ZU.fieldIsValidForType('artworkSize', newItem.itemType)) {
		// drop supplemental info (i.e. everything after +)
		if (ma[2].includes('+')) {
			ma[2] = ma[2].slice(0, ma[2].indexOf('+'));
		}
		// 26 cm. or 33 x 15 cm. or 1/2 in. or 1 1/2 x 15/16 in.
		var dim = ma[2].match(/(?:(?:(?:\d+\s+)?\d+\/)?\d+\s*x\s*)?(?:(?:\d+\s+)?\d+\/)?\d+\s*(?:cm|mm|m|in|ft)\./i);
		if (dim) newItem.artworkSize = dim[0];
	}
}

function processIdentifiers(contextElement, newItem) {
	var isbnNodes = ZU.xpath(contextElement, './/m:identifier[@type="isbn"]', xns),
		isbns = [];
	for (let i = 0; i < isbnNodes.length; i++) {
		const m = isbnNodes[i].textContent.replace(/\s*-\s*/g, '').match(/(?:[\dX]{10}|\d{13})/i);
		if (m) isbns.push(m[0]);
	}
	if (isbns.length) newItem.ISBN = isbns.join(", ");
	
	var issnNodes = ZU.xpath(contextElement, './/m:identifier[@type="issn"]', xns),
		issns = [];
	for (let i = 0; i < issnNodes.length; i++) {
		const m = issnNodes[i].textContent.match(/\b\d{4}\s*-?\s*\d{4}\b/i);
		if (m) issns.push(m[0]);
	}
	if (issns.length) newItem.ISSN = issns.join(", ");
	
	newItem.DOI = ZU.xpathText(contextElement, 'm:identifier[@type="doi"]', xns);
}

function getFirstResult(contextNode, xpaths) {
	for (let i = 0; i < xpaths.length; i++) {
		var results = ZU.xpath(contextNode, xpaths[i], xns);
		if (results.length) return results[0].textContent;
	}
	return null;
}

function doImport() {
	var xml = Zotero.getXML();
	
	var modsElements = ZU.xpath(xml, "/m:mods | /m:modsCollection/m:mods", xns);
	
	for (let iModsElements = 0, nModsElements = modsElements.length;
		iModsElements < nModsElements; iModsElements++) {
		var modsElement = modsElements[iModsElements],
			newItem = new Zotero.Item();
		
		// title
		newItem.title = processTitle(modsElement);
		
		// shortTitle
		var abbreviatedTitle = ZU.xpath(modsElement, 'm:titleInfo[@type="abbreviated"]', xns);
		if (abbreviatedTitle.length) {
			newItem.shortTitle = processTitleInfo(abbreviatedTitle[0]);
		}
		
		// itemType
		newItem.itemType = processItemType(modsElement);
		
		// TODO: thesisType, type
		
		// creators
		let defaultCreatorType = ZU.getCreatorsForType(newItem.itemType)[0];
		processCreators(modsElement, newItem, defaultCreatorType);
		// source
		newItem.source = ZU.xpathText(modsElement, 'm:recordInfo/m:recordContentSource', xns);
		// accessionNumber
		newItem.accessionNumber = ZU.xpathText(modsElement, 'm:recordInfo/m:recordIdentifier', xns);
		// rights
		newItem.rights = ZU.xpathText(modsElement, 'm:accessCondition', xns);
		
		/** US GOVERNMENT EXTENSIONS **/
		
		if (newItem.itemType == 'hearing') {
			newItem.committee = ZU.xpathText(modsElement,
				'm:extension/m:congCommittee/m:name[@type="authority-standard"]', xns);
			newItem.legislativeBody = ZU.capitalizeTitle(ZU.xpathText(modsElement,
				'm:extension/m:chamber', xns), true);
			newItem.session = ZU.xpathText(modsElement,
				'm:extension/m:congress', xns); // this is not great
			newItem.documentNumber = ZU.xpathText(modsElement,
				'm:extension/m:number', xns);
		}
		
		/** SUPPLEMENTAL FIELDS **/
		
		var part = [], originInfo = [];
		
		// host
		var hostNodes = ZU.xpath(modsElement, 'm:relatedItem[@type="host"]', xns);
		for (let i = 0; i < hostNodes.length; i++) {
			var host = hostNodes[i];
			
			// publicationTitle
			if (!newItem.publicationTitle) newItem.publicationTitle = processTitle(host);
			
			// journalAbbreviation
			if (!newItem.journalAbbreviation) {
				const titleInfo = ZU.xpath(host, 'm:titleInfo[@type="abbreviated"]', xns);
				if (titleInfo.length) {
					newItem.journalAbbreviation = processTitleInfo(titleInfo[0]);
				}
			}
			
			// creators of host item will be evaluated by their role info
			// and only if this is missing then they are connected by a generic
			// contributor role
			processCreators(host, newItem, "contributor");
			
			// identifiers
			processIdentifiers(host, newItem);
			
			part = part.concat(ZU.xpath(host, 'm:part', xns));
			originInfo = originInfo.concat(ZU.xpath(host, 'm:originInfo', xns));
		}
		
		if (!newItem.publicationTitle) newItem.publicationTitle = newItem.journalAbbreviation;
		
		// series
		var seriesNodes = ZU.xpath(modsElement, './/m:relatedItem[@type="series"]', xns);
		for (let i = 0; i < seriesNodes.length; i++) {
			var seriesNode = seriesNodes[i];
			var series = ZU.xpathText(seriesNode, 'm:titleInfo/m:title', xns);
			
			if (ZU.fieldIsValidForType('series', newItem.itemType)) {
				newItem.series = series;
			}
			else if (ZU.fieldIsValidForType('seriesTitle', newItem.itemType)) {
				newItem.seriesTitle = series;
			}
			
			if (!newItem.seriesText) {
				newItem.seriesText = ZU.xpathText(seriesNode, 'm:titleInfo/m:subTitle', xns);
			}
			
			if (!newItem.seriesNumber) {
				newItem.seriesNumber = getFirstResult(seriesNode,
					['m:part/m:detail[@type="volume"]/m:number', 'm:titleInfo/m:partNumber']);
			}
			
			processCreators(seriesNode, newItem, "seriesEditor");
		}
		
		// Add part and originInfo from main entry
		part = part.concat(ZU.xpath(modsElement, 'm:part', xns));
		originInfo = originInfo.concat(ZU.xpath(modsElement, 'm:originInfo', xns));
		
		if (part.length) {
			// volume, issue, section
			var details = ["volume", "issue", "section"];
			for (let i = 0; i < details.length; i++) {
				var detail = details[i];
				
				newItem[detail] = getFirstResult(part, ['m:detail[@type="' + detail + '"]/m:number',
					'm:detail[@type="' + detail + '"]']);
			}

			// pages and other extent information
			const extents = ZU.xpath(part, "m:extent", xns);
			for (let i = 0; i < extents.length; i++) {
				var extent = extents[i],
					unit = extent.getAttribute("unit");
				
				if (unit === "pages" || unit === "page") {
					if (newItem.pages) continue;
					var pagesStart = ZU.xpathText(extent, "m:start[1]", xns);
					var pagesEnd = ZU.xpathText(extent, "m:end[1]", xns);
					if (pagesStart || pagesEnd) {
						if (pagesStart == pagesEnd) {
							newItem.pages = pagesStart;
						}
						else if (pagesStart && pagesEnd) {
							newItem.pages = pagesStart + "-" + pagesEnd;
						}
						else {
							newItem.pages = pagesStart + pagesEnd;
						}
					}
				}
				else {
					processExtent(extent.textContent, newItem);
				}
			}
			
			newItem.date = getFirstResult(part, ['m:date[not(@point="end")][@encoding]',
				'm:date[not(@point="end")]',
				'm:date']);
		}

		// physical description
		const extents = ZU.xpath(modsElement, "m:physicalDescription/m:extent", xns);
		for (let i = 0; i < extents.length; i++) {
			processExtent(extents[i].textContent, newItem);
		}

		// identifier
		processIdentifiers(modsElement, newItem);
		
		if (originInfo.length) {
			// edition
			var editionNodes = ZU.xpath(originInfo, 'm:edition', xns);
			if (editionNodes.length) newItem.edition = editionNodes[0].textContent;
			
			// place
			var placeNodes = ZU.xpath(originInfo, 'm:place/m:placeTerm[@type="text"]', xns);
			if (placeNodes.length) newItem.place = placeNodes[0].textContent;
			
			// publisher/distributor
			var publisherNodes = ZU.xpath(originInfo, 'm:publisher', xns);
			if (publisherNodes.length) {
				newItem.publisher = publisherNodes[0].textContent;
				if (newItem.itemType == "webpage" && !newItem.publicationTitle) {
					newItem.publicationTitle = newItem.publisher;
				}
			}
			
			// date
			newItem.date = getFirstResult(originInfo, ['m:copyrightDate[@encoding]',
				'm:copyrightDate',
				'm:dateIssued[not(@point="end")][@encoding]',
				'm:dateIssued[not(@point="end")]',
				'm:dateIssued',
				'm:dateCreated[@encoding]',
				'm:dateCreated']) || newItem.date;
			
			// lastModified
			newItem.lastModified = getFirstResult(originInfo, ['m:dateModified[@encoding]',
				'm:dateModified']);
			
			// accessDate
			newItem.accessDate = getFirstResult(originInfo, ['m:dateCaptured[@encoding]',
				'm:dateCaptured[not(@encoding)]']);
		}
		
		// call number
		newItem.callNumber = ZU.xpathText(modsElement, 'm:classification', xns);
		
		// archiveLocation
		newItem.archiveLocation = ZU.xpathText(modsElement, './/m:location/m:physicalLocation', xns, "; ");

		// attachments and url
		var urlNodes = ZU.xpath(modsElement, 'm:location/m:url', xns);
		for (let urlNode of urlNodes) {
			var access = urlNode.getAttribute("access"),
				usage = urlNode.getAttribute("usage");
			if (access === "raw object") {
				var attachment = {
					title: (urlNode.getAttribute("displayLabel") || "Attachment"),
					url: urlNode.textContent
				};
				if (attachment.url.substr(-4) === ".pdf") {
					attachment.mimeType = "application/pdf";
				}
				else if (/\.html?$/.test(attachment.url)) {
					attachment.mimeType = "text/html";
				}
				else if (/\.jpe?g$/.test(attachment.url)) {
					attachment.mimeType = "image/jpeg";
				}
				else if (/\.png$/.test(attachment.url)) {
					attachment.mimeType = "image/png";
				}
				
				newItem.attachments.push(attachment);
			}
			
			if ((!newItem.url || usage === "primary" || usage === "primary display")
					&& access !== "preview") {
				newItem.url = urlNode.textContent;
			}
			
			if (!newItem.accessDate) {
				newItem.accessDate = urlNode.getAttribute("dateLastAccessed");
			}
		}

		// abstract
		newItem.abstractNote = ZU.xpathText(modsElement, 'm:abstract', xns, "\n\n");
		
		/** NOTES **/
		var noteNodes = ZU.xpath(modsElement, 'm:note', xns);
		for (let i = 0; i < noteNodes.length; i++) {
			var note = noteNodes[i];
			newItem.notes.push({ note:
				(note.hasAttribute("type") ? note.getAttribute("type") + ': ' : '')
				+ note.textContent });
		}

		// ToC - goes into notes
		var tocNodes = ZU.xpath(modsElement, 'm:tableOfContents', xns);
		for (let i = 0; i < tocNodes.length; i++) {
			newItem.notes.push({ note: 'Table of Contents: ' + tocNodes[i].textContent });
		}

		/** TAGS **/
		var tagNodes = ZU.xpath(modsElement, 'm:subject/m:topic', xns);
		for (let i = 0; i < tagNodes.length; i++) {
			newItem.tags.push(ZU.trimInternal(tagNodes[i].textContent));
		}

		// scale
		if (ZU.fieldIsValidForType('scale', newItem.itemType)) {
			var scale = ZU.xpathText(modsElement, 'm:subject/m:cartographics/m:scale', xns);
			if (scale) {
				var m = scale.match(/1\s*:\s*\d+(?:,\d+)/);
				if (m) newItem.scale = m[0];
			}
		}
		
		// Language
		// create an array of languages
		var languageNames = [];
		var languageCodes = [];
		var languageNodes = ZU.xpath(modsElement, 'm:language', xns);
		for (let languageNode of languageNodes) {
			var languageTerms = ZU.xpath(languageNode, 'm:languageTerm', xns);
			
			if (!languageTerms.length
				&& languageNode.childNodes.length === 1
				&& languageNode.firstChild.nodeType === 3 /* Node.TEXT_NODE*/) {
				languageCodes.push(languageNode.firstChild.nodeValue);
				continue;
			}
			
			for (let term of languageTerms) {
				var termType = term.getAttribute("type");

				if (termType === "text") {
					languageNames.push(term.textContent);
				}
				else if (termType === "code" || term.hasAttribute("authority")) {
					languageCodes.push(term.textContent);
				}
			}
		}
		
		// prefer language codes to avoid localized language names in metadata
		let languages = languageCodes.length ? languageCodes : languageNames;
		
		// join the list separated by semicolons & add it to zotero item
		newItem.language = languages.join('; ');
		
		Zotero.setProgress(iModsElements / nModsElements * 100);
		newItem.complete();
	}
}